# 1.리액트 프로젝트 시작하기

## 1.1 리액트란 무엇인가?

    리액트는 UI 기능만 제공
    필요한 기능들은 개발자가 직접 구축
    - 전역 상태 관리
    - 라우팅
    - 빌드 시스템

    리액트 장점
    1. 가상돔을 통해 UI를 빠르게 업데이트
    -> 이전 UI상태와 변경될 UI의 최소 집합을 계산
    -> 사용하지않으면 브라우저 돔을 직접 업데이트 해야함

    2. 함수형 프로그래밍 적극 활용
    -> render 함수는 순수 함수로 작성
    (동일한 입력은 동일한 결과를 반환)
    (입력값에만 의존)

    -> state는 불변 변수로 관리
    (상태의 변경이 항상 새로운 객체를 생성하고 기존의 상태를 변경하지 않음을 의미)

## 1.2 리액트 개발 환경 직접 구축하기

    리액트의 툴체인(toolchain)을 이해하기 위해 한 번쯤 직접 구축해보기

### 1.2.1 Hello World 페이지 만들기

![image](https://github.com/GitHub-SJL/carrotmarket/assets/116176170/24932bce-e00f-4f61-a78a-2775fd4eb0b9)

1.  https://unpkg.com/react@16.14.0/umd/react.development.js
2.  https://unpkg.com/react@16.14.0/umd/react.production.min.js
3.  https://unpkg.com/react-dom@16.14.0/umd/react-dom.development.js
4.  https://unpkg.com/react-dom@16.14.0/umd/react-dom.production.min.js


    링크 1,3 개발환경 파일
    링크 2,4 배포 파일

    React 변수는 react.development.js에서 전역변수로 생성됨
    createElement 함수는 리액트 요소를 반환

    react-dom.development에서 만든 ReactDOM 변수를 사용해서
    우리가 만든 컴포넌트를 react-root돔 요소에 붙인다

### 1.2.2 바벨 사용해 보기

    자바스크립트 코드를 변환해주는 컴파일러
    용도
    1. 최신 문법을 사용하는 용도
    2. 코드 주석 제거
    3. 코드를 압축

    리액트에서는 JSX 문법을 사용하기위해 바벨 사용
    -> JSX 문법으로 작성된 코드를 createElement 함수를 호출하는 코드로 변환

    JSX문법으로 작성하면 마치 HTML 태그를 적는것 같아서 가독성이 훨씬 좋아진다.

```javascript
npm install @babel/core @babel/cli @babel/preset-react

@babel/cli -> 커맨드 라인에서 바벨실행
@babel/preset-react -> JSX 코드를 createElement 함수를 이용한 코드로 변환

npx babel --watch src --out-dir . --presets @babel/preset-react

src에 있는 모든 자바스크립트 파일을 @babel/preset-react 프리셋을 이용해서 변환 후
현재 폴더에 같은 이름의 자바스크립트 파일을 생성

```


### 1.2.3 웹팩의 기본 개념 이해하기
    웹팩: 자바스크립트로 만든 프로그램을 배포하기 좋은 형태로 묶어주는 도구

    1. 배포하기 좋은형태란?
    -> 파일들을 하나로 묶어줌
    -> 애플리케이션을 효율적으로 로딩할 수 있는 번들(bundle)로 만들어줌
    -> 브라우저에서 더 빠르게 로드되고 실행
    2  웹팩 사용하지않고 배포하면 어려운점
    -> 파일 관리와 의존성 복잡
    -> 번들링과 최적화 어려움
    -> 개발 환경 편의성

    웹팩은 ESM(ES6 모듈시스템), commonJS 둘다 지원

    결국 웹팩이 여러 자바스크립트 파일들을 번들링한 하나의 자바스크립트 파일을 HTML의 script 태그에 포함 시키면 된다.
### 1.2.4 웹팩 사용해 보기
```
npm install webpack webpack-cli react react-dom

웹팩 설치하고 기존에 react패키지를 직접 파일로 저장하는 방식 말고 npm으로 react 패키지 설치 

button 컴포넌트를 만들고 다른 js파일에 불러와서 사용하여 웹팩을 사용하기 위한 환경 만들기
```

![image](https://github.com/GitHub-SJL/carrotmarket/assets/116176170/3275e671-d7fc-4bbc-af96-f48050974b62)

    npx webpeck을 통해
    dist 폴더 안에 Button.js와 index.js를 합친 main.js로 번들링이 완료


## 1.3 create-react-app으로 시작하기
    create-react-app은 리액트로 웹 애플리케이션을 만들기 위한 환경을 제공
    장점
    1. 개발 환경을 자동으로 구축
        -바벨,웹팩
        -테스트 시스템
        -HRM(hot-module-replacement)
        -ES6+문법
        -CSS 후처리
    2. 해결법이 여러가지 일때, 합리적인 선택
        - 각각의 장단점을 공부하기에는 시간이 많이 소요
        - 합리적인 선택을 했을 확률이 높다.


### 1.3.1 create-react-app 사용해 보기
```
    npx create-react-app . 
    - 현재폴더에 리액트 설치 해줌    

    HMR을 통해 수정된 부분을 바로 확인 가능
    
    index.js와 연결된 모든 JS파일, css파일은 src폴더 밑에 있어야함
    -> src폴더 바깥에 있는 파일을 import하면 실패

    index.html에서 참조하는 파일은 public 폴더 밑에 있어야 한다.
    -> js,css파일을 script태그, Link태그를 이용하여 연결
    
    index.html 직접연결보단 src폴더내에서 import를 통해 연결 지향
    -> JS파일,CSS파일의 경우 빌드 시 자동으로 압축되기 때문

    이미지,폰트도 src폴더밑에서 포함시키기
    -> 웹팩에서 해시값을 통해 url을 생성
    -> 브라우저 캐싱 효과

    페이지별로 제목을 다르게 줘야할 경우
    -> 검색 엔진 최적화가 필요없다면 react-helmet과 같은 패키지 사용
    -> 필요하다면 Next.js 고려

    PWA는 오프라인에서도 동작하는 웹 애플리케이션을 만들기 위한 기술
    -> 기본적으로 꺼져 있음
    
```

### 1.3.2 주요 명령어 알아보기
    개발 모드로 실행하기
    - npm start
        -> HMR이 동작함
    - https로 실행하는 옵션 제공
        -> 자체 서명된 인증서 제공
        window: set HTTPS=true && npm start
        mac: HTTPS=true npm start
    빌드하기
    - npm run build
        -> 배포 환경에서 사용할 파일 만들어줌
    
    - css파일 저장 경로
        -> build/static/css/main.{해시값}.chunk.css
        -> 여러개의 css파일을 import해도 모두 위의 경로에 저장
    - 리소스 저장 경로(이미지,폰트)
        -> build/static/media
        -> 10kb 보다 작으면 위 경로가 아닌 data url 형식으로 JS파일에 포함

    테스트 코드 실행
    - npm test

    설정 파일 추출하기
    - npm run eject
        -> 숨겨져있던 CRA의 내부 설정 파일이 밖으로 노출
        -> 리액트 툴체인에 익숙한 사람이아니라면 비추천
    - react-scripts 프로젝트를 fork해서 나만의 스크립트를 만들기
    - react-app-rewired 패키지 사용

    - 버전이 올라갈때 변경된 내용을 쉽게 적용할 수 없다는 단점

### 1.3.3 자바스크립트 지원 범위
    ES6의 모든 기능을 지원
    - 지수 연산자
    - async await
    - rest opertator, spread operator
    - dynamic import
    - class field
    - jsx 문법
    - 타입스크립트, 플로 타입 시스템

    기본설정에서는 아무런 폴리필도 포함하지않음

    폴리필
    - 브라우저나 자바스크립트 엔진에서 원래 지원하지 않는 기능을 스크립트를 통해 구현하는 것
    - 객체나 함수를 주입할 때, 그것이 현재 환경에 이미 존재하는지 검사해야 한다 
        -> 만약 해당 기능이 이미 환경에서 지원되고 있다면 폴리필을 사용할 필요가 없다.
        -> 이미 존재하는 기능 위에 똑같은 기능을 덮어쓰면 에러 발생 가능성 있다.

### 1.3.4 코드 분할하기
    사용자에게 필요한 양의 코드만 내려줌
    - 코드 분할 하지않으면 전체 코드를 한번에 내려주기 때문에 첫 페이지가 뜨는 시간이 오래 걸린다.

### 1.3.5 환경 변수 사용하기
    빌드 시점에 환경 변수를 코드로 전달
    process.env.{환경 변수 이름}

    NODE_ENV 환경 변수
    CRA는 NODE_ENV를 기본으로 제공
    - npm start : development 환경
    - npm test : test 환경
    - npm run build : production 환경       

    기타 환경 변수 이용하기
    react는 REACT_APP_접두사를 붙여야함
    process.env.REACT_APP_ 
    
    .env.{환경이름}
    - .env파일을 이용하여 환경별 환경변수를 관리

    autoprefixer
    - CSS를 작성할 때 브라우저 간의 호환성을 위해 필요한 벤더 접두사(vendor prefix)를 자동으로 추가해주는 툴
    - build 실행 후 css파일을 열어보면 벤더 접두사가 추가되어있다.
    

# 3장 중요하지만 헷갈리는 리액트 개념

## 3.1 상탯값과 속성값으로 관리하는 UI 데이터

리액트는 UI데이터를 관리하는 방법을 제공

- 상탯값(state)
    
    → 컴포넌트 내부
    
- 속성값(props)
    
    → 부모 컴포넌트에서 내려줌
    
- 컴포넌트 함수에 **선언형**으로 작성

### 3.1.1 리액트를 사용한 코드의 특징

- 선언형
    
    → 화면을 어떻게 그리는지(명령형)가 아닌 **무엇을 그리는지 나타냄**
    
    → 그렇기에 추상화 단계가 높아서 **DOM이 아닌 환경에서도 UI 표현 가능** ( 모바일 네이티브 )
    

### 3.1.2 컴포넌트의 속성값과 상탯값

- 속성값과 상탯값으로 관리하는 UI 데이터
    
    → **일반 변수**를 이용하여 관리하면 **리액트가 변경됐다는 사실을 모름**
    
- 해당 컴포넌트의 **속성값에 해당하는 부모 컴포넌트가 렌더링**되어도 **같이 렌더링**됨
    
    → 속성값의 변경사항이 바로 반영됨
    
- React.memo
    
    → 원래는 부모 컴포넌트가 렌더링될때 같이 렌더링 되지만 
    
    → 해당 컴포넌트의 **속성값이 바뀔때에만 렌더링 가능하도록함**
    

- 불변 객체로 관리하는 속성값과 상탯값
    - 속성값 : 불변 변수 O
    - 상탯값 : 불변 변수 X
    
    리액트는 state 변경유무를 이전값과 단순비교 하기에 **참조값이 그대로**이면 변경사항이 없다고 판단
    
    → 상탯값도 **불변 변수로 관리**하는게 좋다
    

### 3.1.3 컴포넌트 함수의 반환값

- 다양한 값을 반환할수 있음

생소한 것들

- fragment
    
    → <> </>랑 같음, 
    
    → 배열을 사용하지않고도 여러 개의 요소 표현
    
    **→ key 속성값 필요없음**
    
- null, false
    
    → 아무것도 반환 X
    
- ReactDOM.createPortal(<p>안녕하세요</p>, domNode);
    
    → 현재 위치와 상관없이 **특정 돔 요소에 렌더링**
    
- 조건부 렌더링

## 3.2 리액트 요소와 가상 돔

리액트 요소를 통해 리액트가 내부적으로 어떻게 동작하는지?

그리고 가상돔을 만들고, 실제 돔에 반영할 변경사항을 어떻게 찾는지?

### 3.2.1 리액트 요소 이해하기

- createElement
    
    → **JSX로 작성**하면 createElement가 적용되어 **리액트 요소를 반환** 한다.
    
- type, key, ref, props 구성
    
    → type,key,ref를 제외한 **속성값은 props**로 들어간다.
    
- 불변 객체
    
    → **속성값을 변경할수 없다.**
    

### 3.2.2 리액트 요소가 돔 요소로 만들어지는 과정

데이터 변경에 의한 화면 업데이트

- 렌더 단계(render phase)
    
    → 실제 돔에 반영할 변경사항을 파악
    
    → 최초 리액트 요소 트리로부터 가상 돔을 만들고 이전 가상 돔과 **비교를 통해 변경 사항을 결정**하는 단계
    
    → ReactDOM.render 함수 호출
    
    → 심화 하자면 리액트 v16 부터 리액트 요소는 파이버 라는 구조체로 변환된다.
    
- 커밋 단계(commit phase)
    
    → 변경사항을 **실제 돔에 반영**
    
    → 변경사항 파악하기 위해 가상 돔을 이용
    
- 가상돔
    - 리액트 요소로부터 만들어짐
        
        → 리액트 요소의 **type**에 컴포넌트가 **모두 기본 태그로 변해야함**
        
        → 그래서 모든 컴포넌트 함수가 호출되어야 가상 돔 만들 준비 완료
        
    - 렌더링 할 때마다 가상 돔을 만들고 이전 가상 돔과 비교

## 3.3 리액트 훅 기초 익히기

- hook
    
    → 함수형 컴포넌트에 기능을 추가할 때 사용하는 함수
    
    → 상탯값 사용 ( useState)
    
    → 자식 요소에 접근 가능 (props)
    

### 3.3.1 상탯값 추가하기: useState

- 배치로 처리되는 상탯값 변경 함수
    
    → 상탯값 변경함수는 해당 컴포넌트를 다시 그리면서 자식 컴포넌트도 같이 렌더링 
    
    → 상탯값 변경을 **배치로 처리**  ( 여러 상태 업데이트를 **그룹화하여 한번에 처리**, **비동기**) 
    
    → 동기로 처리하게되면 각 상탯값 변경함수마다 렌더링하기때문에 성능 이슈 생김
    

- 상탯값 변경 함수에 함수 입력하기
    
    → 배치로 처리 되기 때문에 **연속적으로 처리할때**, 해당 변수를 그대로 사용한다면 예상된 값이 아닐수있음
    
    → **함수를 사용하면 해결됨** ( 매개변수는 자신이 호출되기 직전의 상탯값)
    
- 호출 순서가 보장되는 상탯값 변경 함수
    
    → 비동기로 처리되지만 순서가 보장
    

- useSate 훅 하나로 여러 상탯값 관리하기
    
    → 여러개의 상탯값을 객채로 관리하기
    
    → 클래스형에서는 병합했었지만 함수형에서는 **이전 상탯값을 덮어쓴다**.
    
    → 덮어쓰기때문에 **spread 연산자를 활용**하여 이전 값을 복사하는 과정이 필요
    

### 3.3.2 컴포넌트에서 부수 효과 처리하기: useEffect

모든 부수 효과는 useEffect 훅에서 처리하는게 좋다

부수 효과 함수는 렌더링 결과가 **실제돔에 반영된 후 비동기로 호출** 된다.

- 컴포넌트에서 API 호출하기
    
    → 랜더링 할때마다 API 호출하기 때문에 **의존성 배열에 값을 입력**한다.
    
- 많은 버그가 의존성 배열을 잘못 입력하면서 발생
- 이벤트 처리 함수를 등록하고 해제하기
    
    → **부수 효과 함수가 반환하는 값**은 **clean up 함수**이다.
    
- clean up 함수
    
    → **부수 효과 함수가 호출**되기 직전에 호출
    
    → **컴포넌트가 사라지기 직전**에 마지막으로 호출
    
    → 따라서 반드시 호출 될 것이 보장됨
    
    → 의존성 배열을 **빈 배열 입력 시**
    
    → 컴포넌트 생성 될 때만 부수 효과 함수 호출
    
    → 컴포넌트가 사라질 때만 clean up 함수 호출
    

### 3.3.3 훅 직접 만들기

- 커스텀 훅
    
    → 리액트가 제공하는 훅을 이용하여 커스텀 훅 제작 가능
    
    → 커스텀 훅을 이용하여 또 다른 커스텀 훅 제작 가능
    

- 지켜야 할 규칙
    1. 하나의 컴포넌트에서 훅을 **호출하는 순서는 항상 같아야 한다.**
        
        → 조건문, 반복문, 함수안에서 사용하여 호출이 될수도 안될수도 있는 상황을 만들면 안된다.
        
    2. 함수형 컴포넌트 or 커스텀 훅 안에서만 호출되어야 한다.
        
        → 일반 함수에서도 X
        
    
- 훅의 호출 순서가 같아야 하는 이유
    
    → 리액트가 상탯값을 **구분할 수 있는 유일한 정보**는 훅의 사용된 순서
    
    → 리액트가 훅을 관리할때 hooks 배열에 훅이 사용된 순서로 저장하고 저장된 순서를 기반으로 관리
    

## 3.4 컨텍스트 API로 데이터 전달하기

상위 컴포넌트에서 하위에 있는 모든 컴포넌트로 직접 데이터를 전달 가능

### 3.4.1 컨텍스트 API 이해하기

React.createContext(defaultValue) ⇒ {Provider, Consumer}

- Provider
    
    → 상위 컴포넌트에서 데이터를 전달
    
- Consumer
→ 하위 컴포넌트에서 데이터를 사용
    
    → 상위로 올라가면서 가장 가까운 Provider를 찾음
    
    → 전역까지 못찾으면 defaultValue 사용
    
- Provider 컴포넌트의 **속성값이 변경되면서** 하위의 모든 Consumer 컴포넌트는 재렌더링
    
    → 중간 컴포넌트가 **React.memo를 사용**해서 다시 렌더링 되지않도록 설정 되어있어도**Consumer 컴포넌트는 다시 재랜더링**
    

### 3.4.2 컨텍스트 API 활용하기

여러 컨텍스트 객체를 중첩해서 사용하고, Consumer 컴포넌트를 사용하는 하위 컴포넌트에서 컨텍스트 데이터를 수정하는 방법

- 여러 컨텍스트를 중첩해서 사용하기
    
    → **데이터 종류별로 컨텍스트**를 만들어 사용하면 **해당 Consumer 컴포넌트만 랜더링**되기 때문에 렌더링 성능상 이점이 있다.
    
- 하위 컴포넌트에서 컨텍스트 데이터를 수정하기
    
    → 컨텍스트에 상탯값 변경함수를 전달하여 사용한다.
    

### 3.4.3 컨텍스트 API 사용 시 주의할 점

- 불필요한 렌더링
    
    → 렌더링할 때마다 컨텍스트 데이터로 새로운 객체를 전달해서 불필요한 렌더링 발생
    
    - 자세히
        
        ### **컨텍스트 API 사용 시 주의할 점**
        
        컨텍스트의 주요 사용 사례 중 하나는 전역 상태 관리입니다. 즉, 앱의 여러 부분에서 공유되는 데이터를 관리하기 위해 컨텍스트를 사용합니다. 그러나 컨텍스트의 데이터가 변경될 때마다 그 컨텍스트를 사용하는 모든 컴포넌트는 재렌더링됩니다.
        
        ### 문제
        
        다음과 같은 코드를 생각해보겠습니다:
        
        ```jsx
        javascriptCopy code
        const MyContext = React.createContext();
        
        function MyProvider({ children }) {
          const [count, setCount] = useState(0);
        
          return (
            <MyContext.Provider value={{ count, setCount }}>
              {children}
            </MyContext.Provider>
          );
        }
        
        ```
        
        위의 코드에서, **`MyProvider`** 컴포넌트가 리렌더링될 때마다 새로운 객체 (**`{ count, setCount }`**)가 **`MyContext.Provider`**의 **`value`**로 전달됩니다. 이로 인해 **`MyContext`**를 사용하는 모든 컴포넌트도 재렌더링됩니다.
        
        **렌더링 시 새로운** **객체가 생성되는 이유**
        
        JavaScript에서 객체나 배열을 리터럴 방식으로 선언하면 항상 새로운 참조가 생성됩니다.
        
        ```jsx
        javascriptCopy code
        const obj1 = {};
        const obj2 = {};
        
        console.log(obj1 === obj2); // false
        
        ```
        
        **`obj1`**과 **`obj2`**는 리터럴 방식으로 빈 객체를 선언하였지만, 두 객체는 다른 참조를 가지므로 둘은 다르다고 판단됩니다.
        
        이와 비슷하게, React 컴포넌트 내에서 객체를 직접 생성하여 반환하면 컴포넌트가 리렌더링될 때마다 새로운 객체가 생성됩니다.
        
        ### 왜 문제인가?
        
        실제로 **`count`** 값이 변경되지 않았더라도, 매번 새로운 객체를 **`value`**에 전달하면, 이는 불필요한 렌더링을 초래합니다. 이는 앱의 성능을 저하시킬 수 있습니다.
        
        ### 해결 방법
        
        1. **객체 외부에서 생성**: 컨텍스트의 값을 컴포넌트 외부에서 생성하면 항상 동일한 참조를 가진 객체가 전달됩니다.
        2. **useMemo 사용**: **`useMemo`** 훅을 사용하여 객체를 메모이제이션할 수 있습니다.
        
        ```jsx
        javascriptCopy code
        const value = useMemo(() => {
          return { count, setCount };
        }, [count]);
        
        ```
        
        이렇게 하면 **`count`** 값이 변경될 때만 새로운 객체가 생성됩니다. 변경되지 않으면 이전에 생성된 객체가 재사용됩니다.
        
        1. useState를 이용하여 객체 데이터를 전달
            
            → 근데 이렇게 되면 상탯값 변경함수를 전달할때 결국 객체를 사용하게된다.
            
        
        요약하면, 컨텍스트 API를 사용할 때 불필요한 렌더링을 초래하는 새로운 객체나 배열을 무조건적으로 전달하지 않도록 주의해야 합니다.
        
- 잘못된 위치
    
    → Consumer 컴포넌트가 상위 컴포넌트에서 Provider 컴포넌트를 찾지 못하는 경우
    

## 3.5 ref 속성값으로 자식 요소에 접근하기

ref 속성값을 이용하면 **자식요소에 직접 접근**할 수 있다.

→ 자식 요소는 컴포넌트가 될수도 있고, 돔 요소일 수도 있다.

### 3.5.1 ref 속성값 이해하기

- ref 객체의 **current 속성을 이용**하여 자식 요소에 접근

### 3.5.2 ref 속성값 활용하기

- 함수형 컴포넌트에서 ref 속성값 사용하기
    
    → useImperativeHandle 훅을 사용하면 함수형 컴포넌트에서도 변수와 함수를 외부로 노출시킬 수 있다.
    
    → 다른 이름으로 ref 객체를 입력 받아서 내부의 리액트 요소에 연결
    
    → 손자 요소의 ref 속성값을 이용하는 방법은 꼭 필요한 경우에만 사용하기
    
    → 자식의 내부 구조를 외부에서 알아야 하므로 좋은 방법은 아님
    
- forwardRef 함수로 ref 속성값을 직접 처리하기
    
    → **부모 컴포넌트에서 넘어온 ref 속성값**을 직접 처리 가능
    
    → ref를 **ref 이름 그자체로 사용** 가능하게됨
    
- ref 속성값으로 함수 사용하기
    
    → 해당함수는 해당 DOM요소가  생성되거나 제거되는 시점에 호출 된다.
    
     ![image](https://github.com/GitHub-SJL/Practical_React_Programming/assets/116176170/54a2b0c8-179d-43c2-99a5-462f6015668c)

    
    ```jsx
    import { useState, useCallback } from "react";
    
    export default function Index({ inputRef }) {
      const [test, setTest] = useState(INITAL_TEXT);
      const [showText, setShowText] = useState(true);
      
      // 마운트가 되면 setTest하라는 소리
      const setInitialText = useCallback((ref) => ref && setTest(INITAL_TEXT), []);
    		
      return (
        <div>
          {showText && (
            <input
              type="text"
              ref={setInitialText}  
              value={test}
              onChange={(e) => setTest(e.target.value)}
            />
          )}
        </div>
      );
    }
    
    const INITAL_TEXT = "INITAL_TEXT";
    ```
    
    컴포넌트가 렌더링될 때마다 새로운 함수를 ref 속성값으로 넣음
    
    → 함수도 결국 객체이기때문에 렌더링 될때마다 새로운 함수를 생성해서 주기 때문이다.
    
    ref에 적용할 함수를 useCallback을 통해 한번 생성된 함수를 재사용 해야한다.
    

### 3.5.3 ref 속성값 사용 시 주의할 점

ref 객체의 current 속성이 없을 수 있기 때문이다.

→ 조건부 렌더링이 사용된 요소의 ref 객체는 current 속성을 검사하는 코드가 필요

## 3.6 리액트 내장 훅 살펴보기

### 3.6.1 Consumer 컴포넌트 없이 컨텍스트 사용하기 : useContext;

```jsx
function ChildComponent() {
	const user = useContext(UserContext);  // {user: "mike", age: 23}	
}
```

### 3.6.2 렌더링과 무관한 값 저장하기 : useRef

컴포넌트 내부에서 생성되는 값중 렌더링과 무관한 값이 있을때, useRef에 저장

### 3.6.3 메모제이션 훅 : useMemo, useCallback

- useMemo
    
    → 계산량이 많은 함수의 반환값을 재활용
    
    → 의존성 배열에 의해 다시 실행할지 결정가능 
    
- useCallback
    
    → 리액트의 렌더링 성능을 위해 제공되는 훅
    
    → 함수 생성이 성능에 미치는 영향은 적다
    
    → 속성값이 매번 변경되기 때문에 자식 컴포넌트에서 React.memo를 사용해도 불필요한 렌더링이 발생한다.  
    
    - 속성값 변경 자세히
        
        `React.memo`를 사용한 컴포넌트에 대해서, 속성값이 **기본 데이터 타입**(예: 문자열, 숫자, 불린)인 경우는 리렌더링 시에 해당 속성값이 변경되지 않는 한 **리렌더링되지 않습니다.** 
        
        → 이는 **기본 데이터 타입이 불변(immutable)하기 때문**입니다. 즉, 값이 변경되면 새로운 메모리 참조가 생성되는 것이 아니라, 그 값 자체가 변경되거나 새로운 값이 할당됩니다.
        
        **반면**, **객체나 배열과 같은 참조 데이터 타입의 경우**, 매번 **새로운 참조가 생성**될 수 있습니다. 컴포넌트 내에서 객체나 배열을 직접 생성하는 경우 (예: `value={{ name: 'John' }}` 또는 `value={[1, 2, 3]}`) 해당 **컴포넌트가 리렌더링될 때마다 새로운 참조가 생성**되기 때문에, `React.memo`가 불필요한 리렌더링을 방지하는 데 도움을 주지 못합니다.
        
        요약하면:
        
        - 기본 데이터 타입의 속성값 (문자열, 숫자, 불린): `React.memo`가 효과적으로 동작합니다. 값이 변경되지 않는 한 불필요한 리렌더링은 발생하지 않습니다.
        - 참조 데이터 타입의 속성값 (객체, 배열): 컴포넌트 내에서 직접 생성하는 경우, 리렌더링 시마다 새로운 참조가 생성되어 `React.memo`의 효과가 무색해질 수 있습니다. 이를 방지하기 위해 `useMemo`나 `useCallback` 등의 훅을 사용하여 메모이제이션을 할 수 있습니다.
        
        리렌더링 시 타입에 따른 속성값 비교
        
        - 일반 데이터 타입
            
            → 값에 의한 비교
            
        - 객체
            
            → 참조를 비교
            
            → 객체의 내용을 깊게 비교하는 것은 비용이 많이 듦
            
            → 그래서 새로운 객체를 생성해야 한다.
            

### 3.6.4 컴포넌트의 상탯값을 리덕스처럼 관리하기 : useReducer

- 트리의 깊은 곳으로 이벤트 처리 함수 전달하기
    
    → 컨텍스트 API의 Provider를 통해 dispatch 함수를 전달
    
    → **dispatch 함수는 불변성**이 있기 때문에 일반 객체로 전달하는것보다 불필요하게 자주 렌더링 되는 일을 방지
    

### 3.6.5 부모 컴포넌트에서 접근 가능한 함수 구현하기 : useImperativeHandle

- useImperativeHandle를 이용하여 부모 ref 객체를 통해 **자식 컴포넌트의 메서드를 호출** 할수 있다.

### 3.6.6 기타 리액트 내장 훅: useLayoutEffect, useDebugValue

- useLayoutEffect
    
    → useEffect와 비슷하지만 **동기적**으로 호출
    
    → 렌더링 직후 돔 요소의 값을 읽는 경우에 사용
    
- useDebugValue
    
    → 커스텀 훅의 내부 상태를 관찰


# 4장 리액트 실전 활용법

## 4.1 가독성과 생산성을 고려한 컴포넌트 코드 작성법

유지 보수성, 가독성 고려

### 4.1.1 추천하는 컴포넌트 파일 작성법

- 컴포넌트 파일 작성 순서
![image](https://github.com/GitHub-SJL/Practical_React_Programming/assets/116176170/4f3aa51d-e3ae-4a51-84c1-c5b6dfa4ce3f)

1. 파일 최상단에는 속성값 타입을 정의
    
    → 컴포넌트를 사용하려면 컴포넌트의 속성값 타입을 알아야 하므로
    
2. 컴포넌트 함수의 매개변수는 명명된 매개변수 사용
    
    → props.을 반복 X
    
3. 컴포넌트 바같의 변수와 함수는 파일의 가장 미텡 정의
    
    → 변수는 const로 정의하는게 좋
    
    → 커다란 객체는 컴포넌트 외부에서 정의해서 사용
    
- 서로 연관된 코드를 한 곳으로 모으기
    
    → 종류별이 아닌 기능별로 코드를 모아 놓기
    
    → useState를 모두 모아놓기 않고, 해당 변수와 밀접한 함수나 useEffect를 바로 아래에 놓기
    

- 기능을 커스텀 훅으로 분리
    
    → 재사용성, 가독성 
    

### 4.1.2 속성값 타입 정의하기: prop-types

- 속성값에 잘못된 타입이 입력 되면 콘솔에 에러 메세지 출력
- 타입 정의 자체가 훌륭한 문서
- prop-types로 정의할 수 있는 타입

### 4.1.3 가독성을 높이는 조건부 렌더링 방법

- 삼항연산자
- && 연산자
    
    → jsx코드에서는 삼항연산자보다 &&연산자가 가독성이 더 높다
    
    → 이중으로 쓸때, 삼항은 복잡해지지만 && 연산자는 그룹으로 작성 가능함
    
    → &&를 통해 falsy한 값이 나타나면 그것을 반환 모두 아니면 마지막값 반환
    
    → 실제 사용할값이 0이거나 “”일 경우에 falsy로 판단되어서 주의해야함
    
    **`cash`**가 **`null`** 또는 **`undefined`**인 경우에만 조건부 렌더링을 수행
    
    →  ! = null을 추가
    
    ```jsx
    return (
      <div>
        {(cash != null) && <p>{cash}원 보유 중</p>}
      </div>
    )
    ```
    
    falsy ( false, 0, “”, null, undefined, NaN )
    
    0은 falsy한 값이지만 cash ! = null은 느슨한 동등연산자이기 때문에 true로 반환
    
    - **`cash = null;`** → **`false`**
    - **`cash = undefined;`** → **`false`**
    - **`cash = 0;`** → **`true`**
    - **`cash = "";`** → **`true`**
    - **`cash = NaN;`** → **`true`**
    
    따라서 cash ! = null은 true가 되고 뒤의 <p>{cash}원 보유 중</p>를 출력할수있게 된다.
    

### 4.1.4 관심사 분리를 위한 프레젠테이션, 컨테이너 컴포넌트 구분하기

- 프레젠테이션 컴포넌트
    
    → 비즈니스 로직이 없다
    
    → 상탯값이 없다, (마우스오버 와 같은 UI 효과를 위한 상탯값 제외)
    

- 컨테이너 컴포넌트
    
    → 상태값이 있다.
    
    → 비즈니스 로직이 있다.
    

## 4.2 useEffect 훅 실전 활용법

의존성 배열을 잘 관리하지 못해서 발생한 버그는 디버깅이 쉽지 않으므로 제대로 이해하고 사용해야 한다.

### 4.2.1 의존성 배열을 관리하는 방법

대부분의 경우에 입력하지 않아도 되는데 꼭 필요한 경우가 생김

- 부수 효과 함수에서 API를 호출하는 경우
    
    → 불필요한 API 호출 방지해야함
    
    → 의존성배열에 빈배열을 넣을 수도 있지만 새로운 정보를 가져오지 못하기 때문에 올바른 해결책 X
    
    → 호출하는 함수에 **포함된 변수를 빠짐없이 의존성 배열에 추가**해야 한다
    
    → 함수가 수정되고 의존성배열에 추가하는것을 빼먹을때가 많다 ( eslint가 잡아주긴함)
    
    → 모두 추가하지않을경우 오래된 값을 참조하는 경우가 생김
    

- useEffect 훅에서 async await 함수 사용하기
    
    → 부수 효과 함수를 async await으로 만들면 에러 발생
    
    → **부수 효과 함수의 반환값은 항상 함수**여야 하기 때문
    
    → 부수 효과 함수 내에서 async await 함수를 만들어서 호출하자
    
- fetchAndSetUser 함수 재사용하기
    
    → useEffect 훅 안에 있는 fetchAndeSetUser 함수가 밖에서도 필요한 경우
    
    → 해당 함수를 밖으로 빼고 **의존성 배열에 넣는다.**
    
    → 문제점: 렌더링 할 때마다 fetchAndeSetUser 함수를 호출
    
    → 해결점: fetchAndeSetUser함수를 **useCallback훅을 사용**하여 userId가 변경될 때만 갱신
    

### 4.2.2 의존성 배열을 없애는 방법

의존성 배열은 사용하지않는게 좋다

속성값으로 전달되는 함수를 의존성 배열에 넣는 순간 useCallback 등을 사용해서 자주 변경되지 않도록 신경 써서 관리해야 한다.

- 부수 효과 함수 내에서 분기 처리하기
    
    → 의존성 배열을 입력하지않는 대신 if문으로 부수 효과 함수 내에서 실행 시점을 조절
    
- useState의 상탯값 변경 함수에 함수 입력하기
    
    → count +1, [count] X
    
    → prev ⇒ prev + 1 , … O
    
- useReducer 활용하기
    
    → 여러 상탯값을 참조하면서 값을 변경할때 유용
    
    → **dispatch**는 변하지 않는 값이므로 **의존성 배열을 제거** 할 수 있다.
    
- useRef 활용하기
    
    → 속성값으로 전달된 함수의 **함수 내용은 그대로일때**
    

## 4.3 렌더링 속도를 올리기 위한 성능 최적화 방법

1. 이전 렌더링 결과를 재사용할지 판단
2. 컴포넌트 함수를 호출
3. 가상 돔끼리 비교해서 변경된 부분만 실제 돔에 반영

### 4.3.1 React.memo로 렌더링 결과 재사용하기

- 두번째 매개변수가 속성값 비교 함수
    
    → true를 반환하면 이전 렌더링 결과를 재사용
    
    → 입력하지않으면 기본함수(얕은 비교 수행)
    
    → 그래서 불변 객체로 관리하면 변경 여부를 한번에 알수 있음 (가변 객체 였으면 모두 비교해야함)
    

### 4.3.2 속성값과 상탯값을 불변 변수로 관리하는 방법

- 함수의 값이 변하지 않도록 관리하기
    
    →  렌더링 시 JSX로 작성한 코드를 createElement로 변환된 코드를 보면 객체의 내부 속성값이 변경되지 않아도 최상위 객체의 참조값은 항상 변경 된다.
    
    → useState, useReducer의 상탯값 변경함수를 활용 **(불변)**
    
    → **useCallback** 사용 
    
- 객체의 값이 변하지 않도록 관리하기
    
    → 객체를 직접 상태값에 넣지않고 const를 이용하여 상수 변수로 관리 (불변)
    
    → 이때, 다른 상탯값이나 속성값을 이용해서 계산되는 값은 **상수 변수**로 관리 못함
    
    → 배열이 상당히 클때, filter 연산을 수행하는것은 부담스러울수 있다.
    
    → **useMemo 훅**을 이용하여 필요한 경우에만 값이 변하도록 만들기
    

### 4.3.3 가상 돔에서의 성능 최적화

- 요소의 타입 또는 속성을 변경하는 경우
    
    → 조건부렌더링시 <span>으로 시작하고 어떤것은 <div>로 시작할때
    
    → **타입 변경 시** 해당 요소의 **모든 자식 요소도 같이 변경됨** (비효율적)
    
    → **속성 변경**은 **해당하는 속성만** 실제 돔에 반영
    
- 요소를 추가하거나 삭제하는 경우
    
    → 일반적으로 새로운 요소 추가 시 기존 요소는 건드리지 않는다.
    
    → **중간에 요소를 추가하면** 그 뒤에 있는 요소가 변경되지 않았다는것을 알지 못함
    
    → 그래서 모든 값을 비교해야 하므로 연산이 늘어난다.
    
    → key 속성값을 이용하여 같은 **key를 가지는 요소끼리만 비교하도록** 한다.
    
    → key 속성값을 index 정보로 입력하게 될경우 발생하는 문제점
    
    → 배열 중간에 원소를 **추가하거나 삭제하는 경우 or 원소의 순서를 변경하는 경우** 비효율적으로 렌더링
    
    → 따라서 **index를 key값으로 사용하는것은 순서를 변경하지않는 경우에 적합**
